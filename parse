#!/bin/bash

JSON='{}'
KEY='unknown'
VALUES=""

# try not to mess with this structure, make other functions subfunctions of these below
main() {
    initialize "$@"
    parse "$@"
    terminate
}

initialize() {
    # count arguments and add to JSON
    edit_json args.count $#
    edit_json args.input "$*"
    edit_json args.parsed '{}'
}

parse() {
    # if start with --, add as key, else add as value, but if literal '--', then set -- = true
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --*) set_key "$1" ;;
            *) set_value "$1" ;;
        esac
        shift
    done
}

terminate() {
    [[ -n "$VALUES" ]] && set_key "done"
    # output to stdout
    jq . <<< "$JSON"
}

edit_json() {
  local key="$1"
  local val=$(echo "$2" | xargs)

  # Determine the type of the value
  if [[ "$val" =~ ^[0-9]+$ ]]; then
    # Number
    JSON=$(echo "$JSON" | jq ".$key = $val")
  elif [[ "$val" =~ ^\[(.*)\]$ ]]; then
    # Array (must be in JSON format)
    JSON=$(echo "$JSON" | jq --argjson val "$val" ".$key = \$val"arguments)
  elif [[ "$val" =~ ^\{(.*)\}$ ]]; then
    # JSON Object (must be in JSON format)
    JSON=$(echo "$JSON" | jq --argjson val "$val" ".$key = \$val")
  elif [[ "$val" == "true" || "$val" == "false" ]]; then
    # Boolean
    JSON=$(echo "$JSON" | jq ".$key = $val")
  elif [[ "$val" == "null" ]]; then
    # Null
    JSON=$(echo "$JSON" | jq ".$key = null")
  else
    # String (default)
    JSON=$(echo "$JSON" | jq ".$key = \"$val\"")
  fi
}

set_key() {
    # store cached values to previous key, and replace previous key with this key
    edit_json "args.parsed.$KEY" "$VALUES"
    KEY="${1:2}"
    VALUES= #reset
}

set_value () {
    VALUES+=" $1"
    echo "values is now $VALUES"
}

main "$@"
